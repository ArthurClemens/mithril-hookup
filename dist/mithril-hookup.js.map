{"version":3,"file":"mithril-hookup.js","sources":["../src/index.js"],"sourcesContent":["/* global m */\n\nexport const hookup = (closure, addHooks) => (/* internal vnode, unused */) => {\n  let setup = false;\n  \n  const states     = [];\n  let statesIndex  = 0;\n  \n  const depsStates = [];\n  let depsIndex    = 0;\n  \n  const updates    = [];\n  const teardowns  = new Map; // keep track of teardowns even when the update was run only once\n  \n  const scheduleRender = m.redraw;\n  \n  const resetAfterUpdate = () => {\n    updates.length = 0;\n    depsIndex = 0;\n    statesIndex = 0;\n  };\n  \n  const updateDeps = deps => {\n    const index = depsIndex++;\n    const prevDeps = depsStates[index] || [];\n    const shouldRecompute = deps === undefined\n      ? true // Always compute\n      : Array.isArray(deps)\n        ? deps.length > 0\n          ? !deps.every((x,i) => x === prevDeps[i]) // Only compute when one of the deps has changed\n          : !setup // Empty array: only compute at mount\n        : false; // Invalid value, do nothing\n    depsStates[index] = deps;\n    return shouldRecompute;\n  };\n  \n  const effect = (isAsync = false) => (fn, deps) => {\n    const shouldRecompute = updateDeps(deps);\n    if (shouldRecompute) {\n      const runCallbackFn = () => {\n        const teardown = fn();\n        // A callback may return a function\n        // If any, add it to the teardowns\n        if (typeof teardown === \"function\") {\n          // Store this this function to be called at unmount\n          teardowns.set(fn, teardown);\n          // Call re-render at least once\n          teardowns.set(\"_\", scheduleRender);\n        }\n      };\n      updates.push(\n        isAsync\n          ? () => new Promise(resolve => requestAnimationFrame(resolve)).then(runCallbackFn)\n          : runCallbackFn\n      );\n    }\n  };\n  \n  const updateState = (initialValue, newValueFn = value => value) => {\n    const index = statesIndex++;\n    if (!setup) {\n      states[index] = initialValue;\n    }\n    return [\n      states[index],\n      value => {\n        const previousValue = states[index];\n        const newValue = newValueFn(value, index);\n        states[index] = newValue;\n        if (newValue !== previousValue) {\n          scheduleRender(); // Calling redraw multiple times: Mithril will drop extraneous redraw calls, so performance should not be an issue\n        }\n      }\n    ];\n  };\n  \n  // Hook functions\n\n  const useState = initialValue => {\n    const newValueFn = (value, index) =>\n      typeof value === \"function\"\n        ? value(states[index])\n        : value;\n    return updateState(initialValue, newValueFn);\n  };\n  \n  const useReducer = (reducer, initialArg, initFn) => {\n    // From the React docs: You can also create the initial state lazily. To do this, you can pass an init function as the third argument. The initial state will be set to init(initialArg).\n    const initialState = !setup && initFn\n      ? initFn(initialArg)\n      : initialArg;\n    const [state, setState] = updateState(initialState);\n    const dispatch = action =>\n      setState(\n        // Next state:\n        reducer(state, action)\n      );\n    return [state, dispatch];\n  };\n  \n  const useRef = initialValue => {\n    // A ref is a persisted object that will not be updated\n    // Update the ref by setting its `current` property\n    const [value] = updateState({ current: initialValue });\n    return value;\n  };\n  \n  const useMemo = (fn, deps) => {\n    const shouldRecompute = updateDeps(deps);\n    const [memoized, setMemoized] = setup\n      ? updateState()\n      : updateState(fn());\n    if (setup && shouldRecompute) {\n      setMemoized(fn());\n    }\n    return memoized;\n  };\n  \n  const useCallback = (fn, deps) =>\n    useMemo(() => fn, deps);\n  \n  const defaultHooks = {\n    useState,\n    useEffect: effect(),\n    useLayoutEffect: effect(true),\n    useReducer,\n    useRef,\n    useMemo,\n    useCallback,\n  };\n  \n  const hooks = {\n    ...defaultHooks,\n    ...(addHooks && addHooks(defaultHooks))\n  };\n    \n  const update = () => {\n    updates.forEach(call);\n    resetAfterUpdate();\n  };\n  \n  const teardown = () => {\n    [...teardowns.values()].forEach(call);\n  };\n  \n  return {\n    view: vnode => closure(vnode, hooks),\n    oncreate: () => (\n      update(),\n      setup = true\n    ),\n    onupdate: update,\n    onremove: teardown\n  };\n};\n\nconst call = Function.prototype.call.bind(\n  Function.prototype.call\n);\n"],"names":["call","Function","prototype","bind","closure","addHooks","setup","states","statesIndex","depsStates","depsIndex","updates","teardowns","Map","scheduleRender","m","redraw","updateDeps","deps","index","prevDeps","shouldRecompute","undefined","Array","isArray","length","every","x","i","effect","isAsync","fn","runCallbackFn","teardown","set","push","Promise","resolve","requestAnimationFrame","then","updateState","initialValue","newValueFn","value","previousValue","newValue","useMemo","memoized","setMemoized","defaultHooks","useState","useEffect","useLayoutEffect","useReducer","reducer","initialArg","initFn","initialState","state","setState","action","useRef","current","useCallback","hooks","update","forEach","view","vnode","oncreate","onupdate","onremove","values"],"mappings":"8jCA4JMA,EAAOC,SAASC,UAAUF,KAAKG,KACnCF,SAASC,UAAUF,eA3JC,SAACI,EAASC,UAAa,eACvCC,GAAQ,EAENC,EAAa,GACfC,EAAe,EAEbC,EAAa,GACfC,EAAe,EAEbC,EAAa,GACbC,EAAa,IAAIC,IAEjBC,EAAiBC,EAAEC,OAQnBC,EAAa,SAAAC,OACXC,EAAQT,IACRU,EAAWX,EAAWU,IAAU,GAChCE,OAA2BC,IAATJ,KAEpBK,MAAMC,QAAQN,KACZA,EAAKO,OAAS,GACXP,EAAKQ,MAAM,SAACC,EAAEC,UAAMD,IAAMP,EAASQ,MACnCtB,UAETG,EAAWU,GAASD,EACbG,GAGHQ,EAAS,eAACC,iEAAoB,SAACC,EAAIb,MACfD,EAAWC,GACd,KACbc,EAAgB,eACdC,EAAWF,IAGO,mBAAbE,IAETrB,EAAUsB,IAAIH,EAAIE,GAElBrB,EAAUsB,IAAI,IAAKpB,KAGvBH,EAAQwB,KACNL,EACI,kBAAM,IAAIM,QAAQ,SAAAC,UAAWC,sBAAsBD,KAAUE,KAAKP,IAClEA,MAKJQ,EAAc,SAACC,OAAcC,yDAAa,SAAAC,UAASA,GACjDxB,EAAQX,WACTF,IACHC,EAAOY,GAASsB,GAEX,CACLlC,EAAOY,GACP,SAAAwB,OACQC,EAAgBrC,EAAOY,GACvB0B,EAAWH,EAAWC,EAAOxB,GACnCZ,EAAOY,GAAS0B,EACZA,IAAaD,GACf9B,OAqCFgC,EAAU,SAACf,EAAIb,OACbG,EAAkBJ,EAAWC,OACHZ,EAC5BkC,IACAA,EAAYT,QAFTgB,OAAUC,cAGb1C,GAASe,GACX2B,EAAYjB,KAEPgB,GAMHE,EAAe,CACnBC,SA5Ce,SAAAT,UAKRD,EAAYC,EAJA,SAACE,EAAOxB,SACR,mBAAVwB,EACHA,EAAMpC,EAAOY,IACbwB,KAyCNQ,UAAWtB,IACXuB,gBAAiBvB,GAAO,GACxBwB,WAvCiB,SAACC,EAASC,EAAYC,OAEjCC,GAAgBnD,GAASkD,EAC3BA,EAAOD,GACPA,MACsBf,EAAYiB,MAA/BC,OAAOC,aAMP,CAACD,EALS,SAAAE,UACfD,EAEEL,EAAQI,EAAOE,OA+BnBC,OA1Ba,SAAApB,YAGGD,EAAY,CAAEsB,QAASrB,WAwBvCK,QAAAA,EACAiB,YAVkB,SAAChC,EAAIb,UACvB4B,EAAQ,kBAAMf,GAAIb,KAYd8C,wUACDf,EACC5C,GAAYA,EAAS4C,IAGrBgB,EAAS,WACbtD,EAAQuD,QAAQlE,GAxHhBW,EAAQc,OAAS,EACjBf,EAAY,EACZF,EAAc,SA8HT,CACL2D,KAAM,SAAAC,UAAShE,EAAQgE,EAAOJ,IAC9BK,SAAU,kBACRJ,IACA3D,GAAQ,GAEVgE,SAAUL,EACVM,SAXe,aACX3D,EAAU4D,UAAUN,QAAQlE"}